## week8筆記

> 以下針對投影片部分以及老師補充做出整合筆記，詳情請參閱投影片

### 系統程式簡介

* 系統軟體(廣義)

    * 系統軟體(狹義):給程式設計師使用的軟體

        * 如:組譯器、載入器、連結器、巨集處理器、編譯器、直譯器、虛擬機。

    * 應用軟體:給一般大眾使用的軟體

        * 如:試算表(Eexcel)、排版軟體(Word)、瀏覽器(IE、Firefox、Chrome)。

* 系統程式

    * 定義:系統相關的程式設計技術
    
        * 系統指「作業系統」或「電腦系統」

            * 作業系統:

                1. 相關主題:行程管理、執行緒、行程通訊、並行控制、記憶體管理、檔案輸出入、驅動程式。

                2. 此層次的程式設計如:Linux系統程式、Windows系統程式。

            * 電腦系統:
            
                * 相關主題:組合語言、C語言、嵌入式系統。

### 作業系統相關的程式設計

* 執行檔案流程:
    
    * 高階語言 → 編譯器 → 組合語言 → 組譯器 → 目的碼 → 連結器 → 可執行檔 → 載入器 → 載入到記憶體，開始執行。

* C語言:系統程式的主力語言，現今也有人用C++或是Golan。

![](https://github.com/ayd0122344/sp108b/blob/master/week8/Image/chart.jpg)

* 巨集處理器:

    * 「巨集」這個詞的使用暗示著將小命令或動作轉化為一系列指令。

    * `高階語言`常經過巨集處理器展開成沒有巨集的高階語言，如C語言的define，我們可以使用gcc加E參數展開成.i檔。

    * `組合語言`不搭配高階語言也常常會用到巨集。

* 如果系統程式執行環境沒有作業系統，會直接編譯成一個執行映像檔，如:Arduino。

* 連結器:因為每次編譯需要大量目的檔，所以會先事先編譯好目的檔，編譯程式的時候再透過連結器連接進來。如果很多目的檔就會整合成函式庫。

![](https://github.com/ayd0122344/sp108b/blob/master/week8/Image/GNU.jpg)

* 編譯過程中，經由gcc編譯，再透過ld去連結函式庫或目的檔(libm.a、libc.a)變成一個執行檔。

    * 其中libc.a可能一開始由很多.c檔所組成，經過gcc編譯成.o檔，再透過ar(函式庫壓縮工具)壓縮成目標函式庫(通常Linux中副檔名是.a，Windows中副檔名是.lib或.dll)。

### CPU0組合語言

* 馮紐曼電腦架構

    * x86演進中發現依照馮紐曼架構，把所有的單元都接到匯流排去做輸出入的話，快速的處理器就要向慢速的記憶體看齊，損耗效能多。

        * 處理方式:快速的部分用北橋晶片處理，連接處理器和快取；較慢的部分用南橋晶片來處理，連接慢速的部分。

* 指令: 

    * 分為A型、L型、J型:

        ![](https://github.com/ayd0122344/sp108b/blob/master/week8/Image/ALJ.jpg)

        * 32位元中
            * `A型指令`:主要做計算動作，結構為運算代碼+三個暫存器+一個常數。<br>
            * `L型指令`主要做載入儲存的動作，結構為運算代碼+兩個暫存器+一個常數。<br>
            * `J型指令`主要做跳躍動作，結構為運算代碼+常數。<br>
        
            * L型相對A型來說，常數可以大一點，目的是節省空間。

* 指令使用-CPU0一律採用前置表示法，意即目標在前的表示法:


    * ```MOV R1,R2```         #將R2內容移動到R1。<br>
    * ```ADD R1,R2,R3```          #將R3+R2的結果存到R1。<br>
    * ```SUB R1,R2,R3```          #將R3-R2的結果存到R1。<br>
        * IR=14123000 => `14`為SUB指令運算代碼,`123`分別為R1,R2,R3,`000`為沒使用到的部分。<br>
    * ```XOR R1,R2,R3```          #將R3 XOR R2的結果存到R1。<br>
    * ```SHL R1,R2,4```           #將R2的內容進行邏輯(算數)左移4位的運算並存到R1。<br>

    * ```LD R1,[0x28]```          #將記憶體28的內容載入到R1。

    * ```ST R1,[0x32]```          #將R1的內容載入到記憶體32的地方。

* SW-狀態暫存器 (R12)

    ![](https://github.com/ayd0122344/sp108b/blob/master/week8/Image/sw.jpg)

    * N:當ALU輸出是負的，此位為1<br>
    * Z:當ALU輸出是零，此位為1。<br>
    * C:進位時為1。<br>
    * V:超出範圍、溢位時為1。<br>
    * I&T:寫作業系統可以用。<br>
    * M:分為使用者模式跟特權模式。<br>

* 跳躍

    * ```LD R15,ADDR```       #將位址放如R15(程式計數器)，就相當於跳躍動作。

    * ```JMP [0x30]```        #使用相對定址的方式，若原本PC執行到002C的地方，經過此指令和加法運算就會得到新的PC值，也就是PC中跳躍的目的地——005C的地方。

    * ```JLE [0x30]```        #跳躍之前要透過sw確認是否小於等於才可以跳。

* 立即定址

    * ```LDI R1,R2+100```     #將R2+100的值丟給R1，不存取記憶體。

    * ```LDI R1,R0+100```     #將R0+100的值丟給R1，因為R0永遠是0，所以就是直接將100丟給R1。

* 相對定址

    * ```LD R1,[R2+100]```        #將R2+100當成位址去取記憶體內容，再將內容丟入R1

    * ```ST R1,[R2+100]```        #將R1的內容丟到R2+100的記憶體位址

* 索引定址

    * ```LDR R1,[R2+R3]```        #可以存取兩個暫存器的位址相加的記憶體位址

* 絕對定址

    * ```LD R1,[100]```         #中括弧中沒有寫暫存器的話就代表是R0，所以此指令相當於```LD R1,[R0+100]```

* 程式執行

    1. 提取:把程式計數器對應到的記憶體放到IR，CPU0只有一個記憶體，所以程式跟資料放在同一個記憶體中。由於CPU0是32位元處理器，所以每個指令執行完PC要加4。<br>
    2. 解碼:CU對IR解碼之後控制ALU做運算。<br>
    3. 執行:資料流入ALU做運算後，再流回指定暫存器。<br>

* 資料移動

    * MOV使用在單純移動暫存器<br>
        E.g. ```MOV R1,R2```        #R1=R2

    * 若要移動記憶體資料則需使用LD跟ST<br>
        E.g.
        ```
        LD R1,B         #R1=b
        ST R1,A         #A=R1
        ```
* 副程式呼叫

    * 如果在副程式中會做第二層呼叫的話，就把LR保存下來，否則程式會回不去原本的位置。通常LR會保留在堆疊內。

### CPU0組譯器-將組合語言轉換成目的檔

* 組譯方式

    1. 絕對定址:直接使用指令或是編碼來執行組譯動作<br>
    E.g.(L型指令)
    ```LD  Ra,     [Rb  + Cx] ``` (syntax)
    ```LD  R1,             B  ```
    ```00   1,      0    0010 ```

    2. 相對定址:相對於PC的定址方式,要去計算目前為止跟目標的距離<br>
    E.g.(L型指令)
    ```LD  Rd,     [Ra  +   Cx]   ``` (syntax)
    ```LD  R1,     R15  +  (B-PC) ```
    ```00   1,      F       000C  ```




    