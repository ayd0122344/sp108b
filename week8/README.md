## week7筆記

> 以下針對投影片部分以及老師補充做出整合筆記，詳情請參閱投影片

### 系統程式簡介

* 系統軟體(廣義)

    * 系統軟體(狹義):給程式設計師使用的軟體

        * 如:組譯器、載入器、連結器、巨集處理器、編譯器、直譯器、虛擬機。

    * 應用軟體:給一般大眾使用的軟體

        * 如:試算表(Eexcel)、排版軟體(Word)、瀏覽器(IE、Firefox、Chrome)。

* 系統程式

    * 定義:系統相關的程式設計技術
    
        * 系統指「作業系統」或「電腦系統」

            * 作業系統:

                1. 相關主題:行程管理、執行緒、行程通訊、並行控制、記憶體管理、檔案輸出入、驅動程式。

                2. 此層次的程式設計如:Linux系統程式、Windows系統程式。

            * 電腦系統:
            
                * 相關主題:組合語言、C語言、嵌入式系統。

### 作業系統相關的程式設計

* 執行檔案流程:
    
    * 高階語言 → 編譯器 → 組合語言 → 組譯器 → 目的碼 → 連結器 → 可執行檔 → 載入器 → 載入到記憶體，開始執行。

* C語言:系統程式的主力語言，現今也有人用C++或是Golan。

![](https://github.com/ayd0122344/sp108b/blob/master/week8/Image/chart.jpg)

* 巨集處理器:

    * 「巨集」這個詞的使用暗示著將小命令或動作轉化為一系列指令。

    * `高階語言`常經過巨集處理器展開成沒有巨集的高階語言，如C語言的define，我們可以使用gcc加E參數展開成.i檔。

    * `組合語言`不搭配高階語言也常常會用到巨集。

* 如果系統程式執行環境沒有作業系統，會直接編譯成一個執行映像檔，如:Arduino。

* 連結器:因為每次編譯需要大量目的檔，所以會先事先編譯好目的檔，編譯程式的時候再透過連結器連接進來。如果很多目的檔就會整合成函式庫。

![](https://github.com/ayd0122344/sp108b/blob/master/week8/Image/GNU.jpg)

* 編譯過程中，經由gcc編譯，再透過ld去連結函式庫或目的檔(libm.a、libc.a)變成一個執行檔。

    * 其中libc.a可能一開始由很多.c檔所組成，經過gcc編譯成.o檔，再透過ar(函式庫壓縮工具)壓縮成目標函式庫(通常Linux中副檔名是.a，Windows中副檔名是.lib或.dll)。

### CPU0

* 馮紐曼電腦架構

    * x86演進中發現依照馮紐曼架構，把所有的單元都接到匯流排去做輸出入的話，快速的處理器就要向慢速的記憶體看齊，損耗效能多。

        * 處理方式:快速的部分用北橋晶片處理，連接處理器和快取；較慢的部分用南橋晶片來處理，連接慢速的部分。

* 指令: 

    * 分為A型、L型、J型:

        ![](https://github.com/ayd0122344/sp108b/blob/master/week8/Image/ALJ.jpg)

        * 32位元中
            * `A型指令`:主要做計算動作，結構為運算代碼+三個暫存器+一個常數。<br>
            * `L型指令`主要做載入儲存的動作，結構為運算代碼+兩個暫存器+一個常數。<br>
            * `J型指令`主要做跳躍動作，結構為運算代碼+常數。<br>
        
            * L型相對A型來說，常數可以大一點，目的是節省空間。
* 指令使用
    * MOV R1,R2         #將R2內容移動到R1。<br>
    * ADD R1,R2,R3          3將R3+R2的結果存到R1。<br>
    * SUB R1,R2,R3          #將R3-R2的結果存到R1。<br>
        * IR=14123000 => `14`為SUB指令運算代碼,`123`分別為R1,R2,R3,`000`為沒使用到的部分。<br>
    * XOR R1,R2,R3          #將R3 XOR R2的結果存到R1。<br>
    * SHL R1,R2,4           #將R2的內容進行邏輯(算數)左移4位的運算並存到R1。<br>

    * LD R1,[0x28]          #將記憶體28的內容載入到R1。

    * ST R1,[0x32]          #將R1的內容載入到記憶體32的地方。

* SW-狀態暫存器 (R12)

    ![](https://github.com/ayd0122344/sp108b/blob/master/week8/Image/sw.jpg)

    * N:當ALU輸出是負的，此位為1<br>
    * Z:當ALU輸出是零，此位為1。<br>
    * C:進位時為1。<br>
    * V:超出範圍、溢位時為1。<br>
    * I&T:寫作業系統可以用。<br>
    * M:分為使用者模式跟特權模式。<br>

* 跳躍

    * ```LD R15,ADDR```       #將位址放如R15(程式計數器)，就相當於跳躍動作。

    * ```JMP [0x30]```        #使用相對定址的方式，若原本PC執行到002C的地方，經過此指令和加法運算就會得到新的PC值，也就是PC中跳躍的目的地——005C的地方。

    * ```JLE [0x30]```        #跳躍之前要透過sw確認是否小於等於才可以跳。

* 立即定址

    * ```LDI R1,R2+100```     #將R2+100的值丟給R1，不存取記憶體。

    * ```LDI R1,R0+100```     #將R0+100的值丟給R1，因為R0永遠是0，所以就是直接將100丟給R1。

* 相對定址

    * ```LD R1,[R2+100]```        #將R2+100當成位址去取記憶體內容，再將內容丟入R1

    * ```ST R1,[R2+100]```