# 系統程式期中報告-組合語言研究(hackCPU, x86, ARM)

## 前言-組合語言(Assembly language)

* 是任何一種用於電腦、微處理器、微控制器，或其他可程式化器件的低階語言。在不同的裝置中，組合語言對應著不同的機器語言指令集。

* `組譯過程`：使用組合語言編寫的原始碼，然後通過相應的組譯程式將它們轉換成可執行的機器碼。

* `使用輔助記憶碼（Mnemonics）`：用以代替和表示特定低階機器語言的操作。特定的組譯目標指令集可能會包括特定的運算元。許多組譯程式可以辨識代表位址和常數的標籤（Label）和符號（Symbols），這樣就可以用字元來代表運算元而無需採取寫死的方式。普遍地說，每一種特定的組合語言和其特定的機器語言指令集是一對一的。

* 組合語言在系統中角色如下圖所示：

![](https://github.com/ayd0122344/sp108b/blob/master/midterm/image/character.jpg)

## hackCPU

### 以本學期組譯器: asm.c 之成果來解說

* 分為A指令及C指令，其中C指令需要參考內制的表格進行組譯

```
@2          #取位址為2的地方，同時2代表A暫存器的值
D=A         #將A的值放入D暫存器
@3          #取位址為3的地方，同時3代表A暫存器的值
D=D+A       #將D+A的值放入D暫存器
@0          #取位址為0的地方，同時0代表A暫存器的值
M=D         #將D的值放入Memory
```

![](https://github.com/ayd0122344/sp108b/blob/master/week4/Image/PASS2.png)

* 補充上學期範例程式碼進行解說

```
@R0
D=M     #D = RAM[0]
@8
D;JGT   #if R0>0 goto 8
@R1
M=0     #RAM[1]=0
@10
0;JMP   #goto end
@R1
M=1     #R1=1
@10
0;JMP
```

## x86 

### 簡述

* 所有暫存器都可以在16位元和32位元模式下被存取。在16位元模式下，通過上面的列表中兩個字母的縮寫來確定該暫存器。在32位元模式下，這兩個字母的縮寫名字前有「E」（extended，延伸）。例如，「EAX'是累加器暫存器作為一個32位元的值。

* 通用暫存器（GPR） - 32位元命名約定編輯8個GPR是：

1. 累加器暫存器（AX）。用在算術運算。

2. 基址暫存器（BX）。作為一個指向資料的指標（在分段模式下，位於段暫存器DS）。

3. 計數器暫存器（CX）。用於移位/迴圈指令和迴圈。

4. 資料暫存器（DX）。用在算術運算和I/O操作。

5. 堆疊指標暫存器（SP）。用於指向堆疊的頂部。

6. 棧基址指標暫存器（BP）。用於指向堆疊的底部。

7. 源變址暫存器（SI）。在流操作中用作源的一個指標。

8. 目標索引暫存器（DI）。用作在流操作中指向目標的指標。

### 上課教材之03-asmVm/01-add之筆記

* add.s檔案理解結果

![](https://github.com/ayd0122344/sp108b/blob/master/week6/Image/addx86.png)

![](https://github.com/ayd0122344/sp108b/blob/master/week6/Image/addx86-2.png)

* x86之堆疊- foorbar.c 理解結果

![](https://github.com/ayd0122344/sp108b/blob/master/week6/Image/x86stack.png)

> 00-foobar、02-sum的組合語言與大部分同add.s的寫法，在此不再贅述。

## ARM

### ARM基本語法

1. ADD：加法(Addition)

* 語法：ADD{條件}{S} <dest>, <op 1>, <op 2>

* 意義：ADD將把兩個運算元加起來，把結果放置到目標暫存器中。

* 運算元 1是一個暫存器，運算元 2可以是一個暫存器，被移位的暫存器，或一個立即值。

* 加法可以使用於有符號和無符號數。

* 範例:將兩個32位元的數相加。

```
ADD    R0, R1, R2              #R0 = R1 R2

ADD     R0, R1, #256           #R0 = R1 256(立即值須在前加上#)

ADD     R0, R2, R3,LSL#1       #R0 = R2 (R3 << 1)(LSL#1在此代表R3左移1位)
```

2. ADC ：帶進位的加法(Addition with Carry)

* 語法：ADC{條件}{S} <dest>, <op 1>, <op 2>

* 如果要做這樣的加法，必須設定 S字尾來更改進位標誌。

* 範例:將兩個128位的數相加。(以下為32位元電腦,4bit則可做128bit加法)

```
128位目標暫存器:暫存器 0、1、2、和3。

第一個 128位數存在: 暫存器 4、5、6、和7。

第二個 128位數存在: 暫存器 8、9、10、和11。

ADDS R0, R4, R8              #低位元的字(R4, R8)相加

ADCS R1, R5, R9              #以帶進位的方式將第二位元的字(R5, R9)相加

ADCS    R2, R6, R10          #以帶進位的方式將第三位元的字(R5, R9)相加

ADCS    R3, R7, R11          #以帶進位的方式將最高位元的字(R5, R9)相加
```

3. SUB :減法(Subtraction)

* 語法：SUB{條件}{S} <dest>, <op 1>, <op 2>

* SUB用op_1 – op_2，把結果放置到目的暫存器中。

* 運算元 1是一個暫存器，運算元 2可以是一個暫存器，被移位的暫存器，或一個立即值。

* 可以使用於有號數和無號數上。
```
SUB    R0, R1, R2             #R0 = R1 – R2
SUB    R0, R1, #256           # R0 = R1 – 256
SUB    R0, R2, R3,LSL#1        #R0 = R2 – (R3 << 1)
```

4. SBC：帶借位的減法(Subtraction with Carry)

* 語法：SBC{條件}{S} <dest>, <op 1>, <op 2>

* 邏輯運算式： op_1 – op_2 – !carry

* 做兩個運算元的減法，把結果放置到目的暫存器中。

* 使用進位標誌來表示借位，便可做大於 32位的減法。

* 注意：SUB和SBC生成進位標誌的方式不同於常規，需要借位須清除進位標誌。所以，指令要對進位標誌進行一個非操作，亦即在指令執行期間自動的反轉進位位元。

5. RSB :反向減法(Reverse Subtraction)

* 語法：RSB{條件}{S} <dest>, <op 1>, <op 2>

* 意義：SUB用op_2 – op_1，把結果放置到目的暫存器中。

* 運算元 1是一個暫存器，運算元 2可以是一個暫存器，被移位的暫存器，或一個立即值:

* 可以使用於有符號或無符號數。
```
RSB     R0, R1, R2              ; R0 = R2 – R1
RSB     R0, R1, #256            ; R0 = 256 – R1
RSB     R0, R2, R3,LSL#1        ; R0 = (R3 << 1) – R2
```

6. RSC :帶借位的反向減法(Reverse Subtraction with Carry)

* 語法：RSC{條件}{S} <dest>, <op 1>, <op 2>

* 邏輯運算式：op_2 – op_1 – !carry

* 同於SBC，但倒換了兩個運算元的前後位置。


7. AND：邏輯AND(logical AND)

* 語法：AND{條件}{S} <dest>, <op 1>, <op 2>             

* 意義：在兩個運算元上進行AND，把結果放置到目的暫存器中；常用於遮蔽位元。

* 運算元 1是一個暫存器，運算元 2可以是一個暫存器，被移位的暫存器或一個立即值。

* 範例：

```
AND    R0, R0, #3              # R0 = 保持 R0 的[0] 和 [1]，丟棄其餘的位元。
```

8. ORR :邏輯或(logical OR)

* 語法ORR{條件}{S} <dest>, <op 1>, <op 2>

* OR將在兩個運算元上進行邏輯或，把結果放置到目的暫存器中。

* 常用於設定特定的位元。

* 運算元 1是一個暫存器，運算元 2可以是一個暫存器，被移位的暫存器，或一個立即值。

* 範例：
```
ORR    
R0, R0, #3              ; 設定 R0 中[0]和 [1]為1
```

9. BIC ：位元清除(Bit Clear)

* 語法：BIC{條件}{S} <dest>, <op 1>, <op 2>

* BIC是在一個字中清除位的一種方法，與 OR操作相反。

* 運算元 2是一個 32位掩碼(mask)。如果如果在掩碼中設定了某位元為1，則某位元將被清除。未設定的掩碼位位元(設0)則代表此位元保持不變。

* 邏輯運算式：op_1 AND (!op_2)

* 範例：
```
BIC    R0, R0, #%1011          #清除 R0 中的位 0、1、和 3。保持其餘的不變。
```
10. EOR :邏輯異或(logical Exclusive OR)

* 語法：EOR{條件}{S} <dest>, <op 1>, <op 2>

* 意義：在兩個運算元上進行邏輯異或，把結果儲存到目標暫存器中

* 用於對反轉特定的位元。(EOR真值表中二者不同則結果為 1)

* 運算元 1是一個暫存器，運算元 2可以是一個暫存器，被移位的暫存器，或一個立即值

* 範例：
```
EOR    R0, R0, #3              #反轉 R0 中的位 0 和 1
```
* 補充EOR真值表(二者不同則結果為 1):
<table>
　<tr>
　<td>0</td>
　<td>0</td>
  <td>0</td>
　</tr>
　<tr>
　<td>0</td>
　<td>1</td>
  <td>1</td>
　</tr>
　<tr>
　<td>1</td>
　<td>0</td>
  <td>1</td>
　</tr>
　<tr>
　<td>1</td>
　<td>1</td>
  <td>0</td>
　</tr>
</table>

11. MOV ：傳送(Move)

* 語法：MOV{條件}{S} <dest>, <op 1>

* 意義：MOV從另一個暫存器、被移位的暫存器、或一個立即值裝載一個值到目的暫存器。

* 指定相同的暫存器可以實現 NOP指令的效果(NOP：No Operation，意為無操作)，也可以專門移位一個暫存器。

* 範例1：
```
MOV    
R0, R0                  #R0 = R0… NOP 指令
```
* 範例2：

```
  MOV     R0, R0, LSL#3           # R0 = R0 * 8
```
* 範例3：如果 R15是目的暫存器，將修改程式計數器或標誌。這用於返回到呼叫程式碼，方法是把連線暫存器的內容傳送到 R15:
```
MOV    
PC, R14                 #退出到呼叫者

MOVS    PC, R14         #退出到呼叫者並恢復標誌位
 (此例非32-bit體系)
```

12. MVN ：傳送取反的值(MoveNegative)

* 語法：MVN{條件}{S} <dest>, <op 1>

* 與MOV不同之處是在傳送之前位被反轉，所以把一個反值傳送到一個暫存器中。

* 注意：這是邏輯非操作而不是算術操作，這個取反的值加 1才是負值。

* 範例：
```
MVN    R0, #4        #R0 = -5 (4=0100, 取反值為1011=-5)
MVN    R0, #0        #R0 = -1 (0=0000, 取反值為1111=-1)
```
### 移位指令

* ARM處理器組建了可以與資料處理指令(ADC、ADD、AND、BIC、CMN、CMP、EOR、MOV、MVN、ORR、RSB、SBC、SUB、TEQ、TST)一起使用的桶式移位器(barrel shifter)。使用桶式移位器可以影響在 LDR/STR操作中的變址值。

* 移位操作在 ARM指令集中不能作為單獨的指令使用，只能作為指令格式中一個字段，在組合語言中表示為指令中的選項。

    * 例1：資料處理指令的第二個運算元為`暫存器`時：就可以加入移位操作選項對它進行各種移位操作。

    * 例2：資料處理指令的第二個運算元是`立即值`時：在指令中用 8位立即值和 4位迴圈移位來表示移位操作。而對於超過 255的立即值，組譯器會先嘗試在指令中設定迴圈移位數量來表示移位操作，如果不能表示則生成一個錯誤。

* 在邏輯類指令中，邏輯運算指令由指令中 S位元的設定或清除來確定是否影響進位標誌，而比較指令的 S位元總是設定的。

* 指定移位數量方式：

    * (在單一資料傳送指令中指定移位的數量時，只能用立即值而不能用暫存器。)

1. 使用一個立即值(從 0到 31)來指定<br>
2. 使用擁有0~31其中一個值的暫存器來指定<br>

* 下面是給不同的移位型別的六個助記符，其中ASL和LSL是等同的，可以自由互換：
    - LSL 邏輯左移

    - ASL 算術左移

    - LSR 邏輯右移

    - ASR 算術右移

    - ROR 迴圈右移

    - RRX 帶擴充套件的迴圈右移
<hr>

1.	LSL(或ASL)操作

* 對暫存器中的內容進行邏輯(或算術)左移操作，並按操作數所指定的數量向左移位，右端空出的低位元用零來填充。

* 操作數可以是暫存器，也可以是立即數( 0～ 31 )。

* 範例：

```
MOV R0, R1, LSL#2    #將 R1中的內容左移兩位後傳送到 R0。
```

2. LSR操作

* 對暫存器中的內容進行邏輯右移操作，按操作數所指定的數量向右移位，左端空出的低位元用零來填充。

* 操作數可以是暫存器，也可以是立即數( 0～ 31 )。

* 範例：

```
MOV R0, R1, LSR#2   #將 R1中的內容右移兩位後傳送到 R0中，左端補零。
```

3. ASR操作

* 對暫存器中的內容進行算數右移操作，按操作數所指定的數量向右移位，左端用`第31位`的值來填充。

* 操作數可以是暫存器，也可以是立即數( 0～ 31 )。

* 範例：

```
MOV R0, R1, ASR#2   #將 R1中的內容右移兩位後傳送到 R0中，左端用第31位的值來填充。
```

4. ROR操作

* 對暫存器中的內容進行循環右移操作，按操作數所指定的數量向右循環移位，左端用右端移出的位來填充。

* 操作數可以是暫存器，也可以是立即數( 0～ 31 )。

* 當進行 32位的循環右移操作時，暫存器中的值不改變。

* 操作示例：
MOV R0, R1, ROR#2   #將 R1中的內容循環右移兩位後傳送到 R0中。

5. RRX操作

* 對暫存器中的內容進行帶擴展的循環右移操作，按操作數所指定的數量向右循環移位，左端用進位標誌位 C來填充。

* 操作數可以是通用暫存器，也可以是立即數( 0～ 31 )。

* 範例：

```
MOV R0, R1, RRX#2；將 R1中的內容進行帶擴展的循環右移兩位後傳送到 R0中。
```