# 系統程式期中報告-組合語言研究(RISC-V, ARM, x86, CPU0)

## 前言-組合語言(Assembly language)

* 是任何一種用於電腦、微處理器、微控制器，或其他可程式化器件的低階語言。在不同的裝置中，組合語言對應著不同的機器語言指令集。

* `組譯過程`：使用組合語言編寫的原始碼，然後通過相應的組譯程式將它們轉換成可執行的機器碼。

* `使用輔助記憶碼（Mnemonics）`：用以代替和表示特定低階機器語言的操作。特定的組譯目標指令集可能會包括特定的運算元。許多組譯程式可以辨識代表位址和常數的標籤（Label）和符號（Symbols），這樣就可以用字元來代表運算元而無需採取寫死的方式。普遍地說，每一種特定的組合語言和其特定的機器語言指令集是一對一的。

* 組合語言在系統中角色如下圖所示：

![](https://github.com/ayd0122344/sp108b/blob/master/min-term/image/character.jpg)

## hackCPU

### 以本學期組譯器: asm.c 之成果來解說

* 分為A指令及C指令，其中C指令需要參考內制的表格進行組譯

```
@2          #取位址為2的地方，同時2代表A暫存器的值
D=A         #將A的值放入D暫存器
@3          #取位址為3的地方，同時3代表A暫存器的值
D=D+A       #將D+A的值放入D暫存器
@0          #取位址為0的地方，同時0代表A暫存器的值
M=D         #將D的值放入Memory
```

![](https://github.com/ayd0122344/sp108b/blob/master/week4/Image/PASS2.png)

* 補充上學期範例程式碼進行解說

```
@R0
D=M     #D = RAM[0]
@8
D;JGT   #if R0>0 goto 8
@R1
M=0     #RAM[1]=0
@10
0;JMP   #goto end
@R1
M=1     #R1=1
@10
0;JMP
```

## RISC-V

### 簡述

* 是一個基於精簡指令集（RISC）原則的開源指令集架構（ISA）。

* `和多數指令集之差異`：可以自由地用於任何目的，允許任何人設計、製造和銷售RISC-V晶片和軟體而不必支付給任何公司專利費。

* `不是第一個開源指令集，卻具有重要意義`：其設計使其適用於現代計算裝置（如倉庫規模雲端運算機、高階行動電話和微小嵌入式系統）。設計者考慮到了這些用途中的效能與功率效率。該指令集還具有眾多支援的軟體，這解決了新指令集通常的弱點。

## ARM

* 

## x86 

### 簡述

* 所有暫存器都可以在16位元和32位元模式下被存取。在16位元模式下，通過上面的列表中兩個字母的縮寫來確定該暫存器。在32位元模式下，這兩個字母的縮寫名字前有「E」（extended，延伸）。例如，「EAX'是累加器暫存器作為一個32位元的值。

* 通用暫存器（GPR） - 32位元命名約定編輯8個GPR是：

1. 累加器暫存器（AX）。用在算術運算。

2. 基址暫存器（BX）。作為一個指向資料的指標（在分段模式下，位於段暫存器DS）。

3. 計數器暫存器（CX）。用於移位/迴圈指令和迴圈。

4. 資料暫存器（DX）。用在算術運算和I/O操作。

5. 堆疊指標暫存器（SP）。用於指向堆疊的頂部。

6. 棧基址指標暫存器（BP）。用於指向堆疊的底部。

7. 源變址暫存器（SI）。在流操作中用作源的一個指標。

8. 目標索引暫存器（DI）。用作在流操作中指向目標的指標。

### 上課教材之03-asmVm/01-add之筆記

* add.s檔案理解結果

![](https://github.com/ayd0122344/sp108b/blob/master/week6/Image/addx86.png)

![](https://github.com/ayd0122344/sp108b/blob/master/week6/Image/addx86-2.png)

* x86之堆疊- foorbar.c 理解結果

![](https://github.com/ayd0122344/sp108b/blob/master/week6/Image/x86stack.png)

> 00-foobar、02-sum的組合語言與大部分同add.s的寫法，在此不再贅述。